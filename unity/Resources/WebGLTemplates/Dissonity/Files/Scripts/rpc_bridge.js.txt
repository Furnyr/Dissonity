const { patchUrlMappings, formatPrice } = await import("./official_utils.js");
const HANDSHAKE_VERSION = 1;
const HANDSHAKE_ENCODING = "json";
const HANDSHAKE_SDK_VERSION_MINIUM_MOBILE_VERSION = 250;
const UNKNOWN_VERSION_NUMBER = -1;
let HANDSHAKE_SDK_VERSION = "[[[ SDK_VERSION ]]]§";
const RESPONSE_TYPE = "code";
const PROMPT = "none";
const OPCODES = {
    Handshake: 0,
    Frame: 1,
    Close: 2,
    Hello: 3
};
const CLOSE_CODES = {
    Normal: 1000
};
const ALLOWED_ORIGINS = new Set([
    window.location.origin,
    "https://discord.com",
    "https://discordapp.com",
    "https://ptb.discord.com",
    "https://ptb.discordapp.com",
    "https://canary.discord.com",
    "https://canary.discordapp.com",
    "https://staging.discord.co",
    "http://localhost:3333",
    "https://pax.discord.com",
    "null",
]);
const COMMANDS = {
    Dispatch: "DISPATCH",
    Authorize: "AUTHORIZE",
    Authenticate: "AUTHENTICATE"
};
const EVENTS = {
    Error: "ERROR",
    Ready: "READY"
};
const PLATFORMS = {
    Desktop: "desktop",
    Mobile: "mobile"
};
const STATE_CODES = {
    OutsideDiscord: -1,
    Errored: 0,
    Loading: 1,
    Ready: 2,
    Closed: 3
};
const _VARIABLE_SEPARATOR = "§";
let currentState = STATE_CODES.Loading;
let disableInfoLogs = "[[[ DISABLE_INFO_LOGS ]]]§";
let unityReady = false;
let clientId = "";
let mobileAppVersion = "";
let readyData = "";
let authorizeData = "";
let serverPayloadData = "";
let authenticateData = "";
let listeners = [];
let _unityInstance = null;
function Handshake() {
    if (typeof window == "undefined") {
        currentState = STATE_CODES.OutsideDiscord;
        return;
    }
    const bridge = document.querySelector('script[data-web]');
    const isWeb = bridge.getAttribute('data-web') == "true";
    if (isWeb) {
        window.outsideDiscord = true;
        currentState = STATE_CODES.OutsideDiscord;
        return;
    }
    const query = RequestQuery();
    if (!query || !query.frame_id || !query.instance_id || !query.platform) {
        window.outsideDiscord = true;
        currentState = STATE_CODES.OutsideDiscord;
        return;
    }
    disableInfoLogs = ParseBuildVariable(disableInfoLogs, "boolean");
    AddListeners(InitialBridgeListener, NonFrameOpcode);
    const clientIdVariable = "[[[ CLIENT_ID ]]]§";
    clientId = ParseBuildVariable(clientIdVariable);
    HANDSHAKE_SDK_VERSION = ParseBuildVariable(HANDSHAKE_SDK_VERSION);
    mobileAppVersion = query.mobile_app_version ?? null;
    const majorMobileVersion = ParseMajorMobileVersion();
    const handshakePayload = {
        v: HANDSHAKE_VERSION,
        encoding: HANDSHAKE_ENCODING,
        client_id: clientId,
        frame_id: query.frame_id
    };
    if (query.platform === PLATFORMS.Desktop || majorMobileVersion >= HANDSHAKE_SDK_VERSION_MINIUM_MOBILE_VERSION) {
        handshakePayload["sdk_version"] = HANDSHAKE_SDK_VERSION;
    }
    InternalSend([
        OPCODES.Handshake,
        handshakePayload
    ]);
}
function NonFrameOpcode(message) {
    if (!ALLOWED_ORIGINS.has(message.origin))
        return;
    const opcode = message.data?.[0];
    if (opcode == OPCODES.Frame)
        return;
    switch (opcode) {
        case OPCODES.Hello: {
            break;
        }
        case OPCODES.Close: {
            StopListening();
            if (unityReady) {
                SendToUnity({ method: "_HandleMessage", payload: SerializePayload(message.data) });
            }
            break;
        }
        case OPCODES.Handshake:
            break;
    }
}
async function InitialBridgeListener(message) {
    if (!ALLOWED_ORIGINS.has(message.origin))
        return;
    const opcode = message.data?.[0];
    if (opcode != OPCODES.Frame)
        return;
    const payload = message.data?.[1];
    const data = payload?.data;
    const event = payload?.evt;
    const command = payload?.cmd;
    switch (command) {
        case COMMANDS.Dispatch: {
            if (event != EVENTS.Ready)
                break;
            const data = SerializePayload(message.data);
            readyData = data;
            if (!disableInfoLogs)
                console.log("[Dissoniy BridgeLib]: Connected to RPC!");
            const disableLogOverrideVariable = "[[[ DISABLE_CONSOLE_LOG_OVERRIDE ]]]§";
            const disableLogOverride = ParseBuildVariable(disableLogOverrideVariable, "boolean");
            if (disableLogOverride == null) {
                currentState = STATE_CODES.Errored;
                throw new Error(`[Dissonity BridgeLib]: DISABLE_CONSOLE_LOG_OVERRIDE has an invalid value (${disableLogOverride}). Accepted values are (1/True) and (0/False)`);
            }
            if (!disableLogOverride) {
                OverrideConsoleLogging();
            }
            const mappingsVariable = "[[[ MAPPINGS ]]]§";
            const patchUrlMappingsConfigVariable = "[[[ PATCH_URL_MAPPINGS_CONFIG ]]]§";
            const mappingsMap = ParseBuildVariable(mappingsVariable, "map");
            const patchUrlMappingsConfigMap = ParseBuildVariable(patchUrlMappingsConfigVariable, "map");
            const mappings = MapToMappingArray(mappingsMap);
            const patchUrlMappingsConfig = MapToConfig(patchUrlMappingsConfigMap);
            if (mappings.length > 0) {
                if (!disableInfoLogs)
                    console.log(`[Dissoniy BridgeLib]: Patching (${mappings.length}) url mappings...`);
                patchUrlMappings(mappings, patchUrlMappingsConfig);
            }
            const oauthScopesVariable = "[[[ OAUTH_SCOPES ]]]§";
            const oauthScopes = ParseBuildVariable(oauthScopesVariable, "string[]");
            InternalSend([
                OPCODES.Frame,
                {
                    cmd: COMMANDS.Authorize,
                    nonce: GetNonce(),
                    args: {
                        client_id: clientId,
                        scope: oauthScopes,
                        response_type: RESPONSE_TYPE,
                        prompt: PROMPT,
                        state: ""
                    }
                }
            ]);
            break;
        }
        case COMMANDS.Authorize: {
            if (event == EVENTS.Error) {
                currentState = STATE_CODES.Closed;
                RemoveListeners(InitialBridgeListener);
                InternalSend([
                    OPCODES.Close,
                    {
                        code: CLOSE_CODES.Normal,
                        message: "User unauthorized scopes",
                        nonce: GetNonce()
                    }
                ]);
                break;
            }
            const serializedData = SerializePayload(message.data);
            authorizeData = serializedData;
            if (!disableInfoLogs)
                console.log("[Dissoniy BridgeLib]: Authorized!");
            const tokenRequestPathVariable = "[[[ TOKEN_REQUEST_PATH ]]]§";
            const tokenRequestPath = ParseBuildVariable(tokenRequestPathVariable, "string");
            const serverRequestVariable = '[[[ SERVER_REQUEST ]]]§';
            const serverRequest = ParseBuildVariable(serverRequestVariable);
            let body = {
                code: data.code
            };
            if (serverRequest != null) {
                delete serverRequest.code;
                body = {
                    code: data.code,
                    ...serverRequest
                };
            }
            const response = await fetch(`/.proxy${tokenRequestPath}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
            });
            const json = await response.json();
            if (!json.token) {
                throw new Error("[Dissonity]: The server JSON response didn't include a 'token' field");
            }
            serverPayloadData = JSON.stringify(json);
            InternalSend([
                OPCODES.Frame,
                {
                    cmd: COMMANDS.Authenticate,
                    nonce: GetNonce(),
                    args: {
                        access_token: json.token
                    }
                }
            ]);
            break;
        }
        case COMMANDS.Authenticate: {
            RemoveListeners(InitialBridgeListener);
            const data = SerializePayload(message.data);
            authenticateData = data;
            currentState = STATE_CODES.Ready;
            if (!disableInfoLogs)
                console.log("[Dissoniy BridgeLib]: Authenticated!");
            if (unityReady) {
                AddListeners(Bridge);
                DispatchMultiEvent();
            }
            break;
        }
    }
}
function Bridge(message) {
    if (message.data.iframeBridge)
        return;
    if (!ALLOWED_ORIGINS.has(message.origin))
        return;
    const data = SerializePayload(message.data);
    SendToUnity({ method: "_HandleMessage", payload: data });
}
function AddListeners(...args) {
    for (const listener of args) {
        window.addEventListener("message", listener);
        listeners.push(listener);
    }
}
function RemoveListeners(...args) {
    for (const listener of args) {
        window.removeEventListener("message", listener);
        listeners.splice(listeners.indexOf(listener), 1);
    }
}
function SendToUnity(message) {
    const { method, payload } = message;
    _unityInstance?.SendMessage("_DissonityBridge", method, payload);
}
function ParseBuildVariable(variable, type = "string") {
    const raw = variable.split("]]] ")[1].slice(0, -1);
    if (type == "string")
        return raw;
    if (type == "boolean") {
        if (/1|true/i.test(variable))
            return true;
        else if (/0|false/i.test(variable))
            return false;
        throw new Error("[Dissonity BridgeLib]: Invalid boolean string");
    }
    if (type == "string[]") {
        const array = raw.split(",");
        if (array.length == 1 && array[0] == "")
            return [];
        return array;
    }
    if (type == "json") {
        try {
            return JSON.parse(raw);
        }
        catch {
            return null;
        }
    }
    const map = new Map();
    const array = raw.split(",");
    if (array.length < 2)
        return map;
    let lastValue = "";
    for (let i = 0; i < array.length; i++) {
        if (i % 2 == 0) {
            lastValue = array[i];
            continue;
        }
        else {
            const value = array[1];
            if (value == "True")
                map.set(lastValue, true);
            else if (value == "False")
                map.set(lastValue, false);
            else
                map.set(lastValue, value);
            continue;
        }
    }
    return map;
}
function MapToMappingArray(map) {
    const array = [];
    for (const [key, value] of map) {
        array.push({
            prefix: key,
            target: value
        });
    }
    return array;
}
function MapToConfig(map) {
    return {
        patchFetch: map.get("patchFetch"),
        patchWebSocket: map.get("patchWebSocket"),
        patchXhr: map.get("patchXhr"),
        patchSrcAttributes: map.get("patchSrcAttributes")
    };
}
function SerializePayload(messageData) {
    const sendMessage = { data: messageData };
    const messageStr = JSON.stringify(sendMessage, (_, value) => {
        if (typeof value == "bigint")
            return value.toString();
        else
            return value;
    });
    return messageStr;
}
function GetNonce() {
    const uuid = new Array(36);
    for (let i = 0; i < 36; i++) {
        uuid[i] = Math.floor(Math.random() * 16);
    }
    uuid[14] = 4;
    uuid[19] = uuid[19] &= ~(1 << 2);
    uuid[19] = uuid[19] |= (1 << 3);
    uuid[8] = uuid[13] = uuid[18] = uuid[23] = "-";
    return uuid.map((x) => x.toString(16)).join("");
}
function OverrideConsoleLogging() {
    const consoleLevels = ["log", "warn", "debug", "info", "error"];
    const captureLog = (level, message) => {
        InternalSend([OPCODES.Frame, {
                cmd: "CAPTURE_LOG",
                nonce: GetNonce(),
                args: {
                    level,
                    message
                }
            }]);
    };
    consoleLevels.forEach((level) => {
        const _consoleMethod = console[level];
        const _console = console;
        if (!_consoleMethod) {
            return;
        }
        console[level] = function () {
            const args = [].slice.call(arguments);
            const message = "" + args.join(" ");
            captureLog(level, message);
            _consoleMethod.apply(_console, args);
        };
    });
}
function InternalSend(message) {
    const source = window.parent.opener ?? window.parent;
    const sourceOrigin = !!document.referrer ? new URL(document.referrer).origin : "*";
    source.postMessage(message, sourceOrigin);
}
function DispatchMultiEvent() {
    const sendMessage = {
        nonce: null,
        payload: {
            raw_multi_event: {
                ready: readyData,
                authorize: authorizeData,
                authenticate: authenticateData,
                response: serverPayloadData
            }
        }
    };
    SendToUnity({ method: "_ReceiveMultiEvent", payload: JSON.stringify(sendMessage) });
    ClearData();
}
function ClearData() {
    clientId = "";
    readyData = "";
    authorizeData = "";
    serverPayloadData = "";
    authenticateData = "";
}
function ParseMajorMobileVersion() {
    if (mobileAppVersion && mobileAppVersion.includes(".")) {
        try {
            return parseInt(mobileAppVersion.split(".")[0]);
        }
        catch {
            return UNKNOWN_VERSION_NUMBER;
        }
    }
    return UNKNOWN_VERSION_NUMBER;
}
export function SetUnityInstance(instance) {
    if (_unityInstance)
        return;
    _unityInstance = instance;
}
export function InterfaceBridgeListener(message) {
    const { command, nonce, payload } = message;
    switch (command) {
        case "Send": {
            Send(payload);
            break;
        }
        case "RequestQuery": {
            const query = RequestQuery();
            const formattedPayload = {
                nonce,
                payload: {
                    str: JSON.stringify(query)
                }
            };
            SendToUnity({ method: "_ReceiveString", payload: JSON.stringify(formattedPayload) });
            break;
        }
        case "RequestState": {
            RequestState(nonce);
            break;
        }
        case "RequestPatchUrlMappings": {
            const parsedPayload = JSON.parse(payload);
            RequestPatchUrlMappings(nonce, parsedPayload.str);
            break;
        }
        case "RequestFormatPrice": {
            const parsedPayload = JSON.parse(payload);
            RequestFormatPrice(nonce, parsedPayload.str);
            break;
        }
        case "StopListening": {
            StopListening();
            break;
        }
    }
}
function Send(stringifiedMessage) {
    const message = JSON.parse(stringifiedMessage);
    const source = window.parent.opener ?? window.parent;
    const sourceOrigin = !!document.referrer ? document.referrer : "*";
    source.postMessage(message, sourceOrigin);
}
function StopListening() {
    currentState = STATE_CODES.Closed;
    for (const listener of listeners) {
        window.removeEventListener("message", listener);
    }
}
function RequestQuery() {
    function getQueryData() {
        const isParent = window.location.search.includes("?");
        const queryStringKeyValue = (isParent)
            ? window.location.search.replace("?", "").split("&")
            : window.parent.location.search.replace("?", "").split("&");
        const qsJsonObject = {};
        if (queryStringKeyValue.length != 0) {
            for (let i = 0; i < queryStringKeyValue.length; i++) {
                qsJsonObject[queryStringKeyValue[i].split("=")[0]] = queryStringKeyValue[i].split("=")[1];
            }
        }
        return qsJsonObject;
    }
    return getQueryData();
}
function RequestState(nonce) {
    const sendMessage = {
        nonce,
        payload: {
            code: currentState,
        }
    };
    SendToUnity({ method: "_ReceiveState", payload: JSON.stringify(sendMessage) });
    if (!unityReady) {
        unityReady = true;
        if (currentState == STATE_CODES.Ready) {
            AddListeners(Bridge);
            DispatchMultiEvent();
        }
    }
}
function RequestPatchUrlMappings(nonce, stringifiedMessage) {
    const { mappings, config } = JSON.parse(stringifiedMessage);
    if (mappings.length != 0) {
        patchUrlMappings(mappings, config);
    }
    const sendMessage = {
        nonce
    };
    SendToUnity({ method: "_ReceiveEmpty", payload: JSON.stringify(sendMessage) });
}
function RequestFormatPrice(nonce, stringifiedMessage) {
    const { amount, currency, locale } = JSON.parse(stringifiedMessage);
    const result = formatPrice({ amount, currency }, locale);
    const sendMessage = {
        nonce,
        payload: {
            str: result
        }
    };
    SendToUnity({ method: "_ReceiveString", payload: JSON.stringify(sendMessage) });
}
Handshake();
